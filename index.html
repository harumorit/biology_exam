<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>ç”Ÿç‰©â…¡ æœŸæœ«å¯¾ç­–ã‚¯ã‚¤ã‚º</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body { margin:0; font-family: system-ui, -apple-system, "Segoe UI", sans-serif; background:#0b0f14; color:#e8eef7; }
    header { padding:16px; border-bottom:1px solid #333; background:#111826; position:sticky; top:0; z-index:10; }
    h1 { margin:0 0 10px; font-size:18px; }
    select, button, label, input {
      padding:8px 12px; margin-right:6px; background:#1b2435; color:#fff;
      border:1px solid #444; border-radius:8px; cursor:pointer;
    }
    button.secondary { background:#172033; }
    button.danger { background:#3d0f1a; border-color:#6b2331; }
    button.ok { background:#0f3d2e; border-color:#1f6b53; }
    button:disabled { opacity:.55; cursor:not-allowed; }
    main { max-width: 980px; margin: 0 auto; padding: 20px; }
    .card { background:#121923; padding:20px; border-radius:12px; border:1px solid #333; }
    .choice { display:block; width:100%; margin:8px 0; padding:10px; text-align:left; }
    .result { margin-top:16px; padding:12px; border-radius:8px; display:none; }
    .good { background:#0f3d2e; }
    .bad { background:#3d0f1a; }
    .meta { margin-top:10px; font-size:13px; color:#aaa; white-space:pre-wrap; }
    .row { display:flex; flex-wrap:wrap; gap:8px; align-items:center; }
    .modalBackdrop{
      position:fixed; inset:0; background:rgba(0,0,0,.55);
      display:none; align-items:center; justify-content:center; padding:18px;
      z-index: 50;
    }
    .modal{
      width:min(920px, 100%); max-height: 85vh; overflow:auto;
      background:#121923; border:1px solid #333; border-radius:14px; padding:16px;
    }
    .modal h2{ margin:0 0 10px; font-size:16px; }
    .listItem{
      border:1px solid #2a3448; border-radius:12px; padding:10px; margin:8px 0;
      display:flex; gap:10px; align-items:flex-start; justify-content:space-between;
    }
    .listItem .left{ flex:1; }
    .small{ font-size:12px; color:#aab; }
    .pill{ display:inline-block; font-size:12px; padding:2px 8px; border-radius:999px; border:1px solid #2a3448; color:#aab; }
    .spacer { flex: 1; }
    .hint { color:#aab; font-size:12px; margin-top:6px; }
    .numSelectWrap { display:inline-flex; align-items:center; gap:6px; }
    .numSelectWrap select { min-width: 86px; }

    .modeWrap { display:inline-flex; align-items:center; gap:6px; }
    .modeWrap select { min-width: 190px; }

    .kbd { font-size:12px; border:1px solid #2a3448; padding:2px 6px; border-radius:6px; color:#aab; }
  </style>
</head>

<body>
<header>
  <h1>ç”Ÿç‰©â…¡ æœŸæœ«å¯¾ç­–ã‚¯ã‚¤ã‚º</h1>

  <div class="row">
    <select id="lectureFilter">
      <option value="all">å…¨è¬›ç¾©</option>
      <option value="1">ç¬¬1è¬›</option><option value="2">ç¬¬2è¬›</option><option value="3">ç¬¬3è¬›</option>
      <option value="4">ç¬¬4è¬›</option><option value="5">ç¬¬5è¬›</option><option value="6">ç¬¬6è¬›</option>
      <option value="7">ç¬¬7è¬›</option><option value="8">ç¬¬8è¬›</option><option value="9">ç¬¬9è¬›</option>
      <option value="10">ç¬¬10è¬›</option><option value="11">ç¬¬11è¬›</option><option value="12">ç¬¬12è¬›</option>
      <option value="13">ç¬¬13è¬›</option>
    </select>

    <span class="numSelectWrap">
      <span class="pill">å‡ºé¡Œæ•°</span>
      <select id="countSelect" title="1å›ã®å‡ºé¡Œæ•°ï¼ˆãƒ•ã‚£ãƒ«ã‚¿å¾Œã®å•é¡Œæ•°ã‚ˆã‚Šå¤šã„å ´åˆã¯è‡ªå‹•ã§æœ€å¤§ã«ã—ã¾ã™ï¼‰">
        <option value="10">10</option>
        <option value="20">20</option>
        <option value="30">30</option>
        <option value="50">50</option>
        <option value="80">80</option>
        <option value="100">100</option>
        <option value="150">150</option>
        <option value="200">200</option>
        <option value="all" selected>å…¨éƒ¨</option>
      </select>
    </span>

    <!-- â˜…å­¦ç¿’ãƒ¢ãƒ¼ãƒ‰ï¼ˆè¿½åŠ ï¼‰ -->
    <span class="modeWrap">
      <span class="pill">ãƒ¢ãƒ¼ãƒ‰</span>
      <select id="modeSelect" title="å‹‰å¼·æ–¹æ³•ã‚’åˆ‡ã‚Šæ›¿ãˆ">
        <option value="normal" selected>é€šå¸¸ï¼ˆ4æŠï¼‰</option>
        <option value="study_lock">ğŸ“˜ å‹‰å¼·ï¼šç†è§£ã—ãŸæŠ¼ã™ã¾ã§é€²ã‚ãªã„</option>
        <option value="two_choice">âš¡ äºŒæŠï¼šæ­£ã—ã„ / èª¤ã‚Š</option>
        <option value="term_desc">ğŸ§  å˜èª â†’ èª¬æ˜ï¼ˆ4æŠï¼‰</option>
      </select>
    </span>

    <button id="btnStart">é–‹å§‹</button>
    <button id="btnWrong" class="secondary">é–“é•ã„å¾©ç¿’</button>
    <button id="btnWrongList" class="secondary">é–“é•ã„ä¸€è¦§</button>
    <button id="btnWrongReset" class="danger">é–“é•ã„ãƒªã‚»ãƒƒãƒˆ</button>

    <span class="spacer"></span>

    <button id="btnLogin" class="secondary">Googleã§ãƒ­ã‚°ã‚¤ãƒ³</button>
    <button id="btnLogout" class="secondary" style="display:none;">ãƒ­ã‚°ã‚¢ã‚¦ãƒˆ</button>
    <span class="pill" id="userLabel" style="display:none;"></span>
  </div>

  <div class="meta" id="topStats"></div>
  <div class="hint" id="modeHint" style="display:none;"></div>
</header>

<main>
  <div class="card">
    <h2 id="question">é–‹å§‹ã‚’æŠ¼ã—ã¦ãã ã•ã„</h2>
    <div id="choices"></div>

    <div class="result" id="resultBox">
      <div id="resultText"></div>
      <div class="meta" id="explanation"></div>

      <div class="row" style="margin-top:10px;">
        <button id="btnToggleWrong" class="secondary">ã“ã®å•é¡Œã‚’ã€Œé–“é•ã„ã€ã«ã™ã‚‹</button>

        <button id="btnUnderstood" class="secondary" style="display:none;">
          âœ… ç†è§£ã—ãŸï¼ˆæ¬¡ã¸ï¼‰
        </button>

        <button id="btnNext" class="ok">æ¬¡ã¸</button>
      </div>
    </div>

    <div class="meta" id="status"></div>
  </div>
</main>

<!-- é–“é•ã„ä¸€è¦§ãƒ¢ãƒ¼ãƒ€ãƒ« -->
<div class="modalBackdrop" id="modalBg">
  <div class="modal">
    <div class="row" style="justify-content:space-between;">
      <h2>é–“é•ã„ä¸€è¦§</h2>
      <button id="btnCloseModal" class="secondary">é–‰ã˜ã‚‹</button>
    </div>

    <div class="row" style="margin:10px 0;">
      <span class="pill" id="wrongCountPill">0 ä»¶</span>
      <button id="btnExportWrong" class="secondary">IDã‚’ã‚³ãƒ”ãƒ¼</button>
    </div>

    <div class="meta" style="margin:8px 0;">
      ãƒ»ä¸€è¦§ã®ã€Œè¡¨ç¤ºã€ã§å•é¡Œã‚’ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã§ãã¾ã™  
      ãƒ»ã€Œè§£é™¤ã€ã§é–“é•ã„ãƒªã‚¹ãƒˆã‹ã‚‰å¤–ã›ã¾ã™
    </div>

    <div id="wrongList"></div>
  </div>
</div>

<script type="module">
  import { QUESTIONS } from "./all_questions.js";
  import {
    watchAuthState,
    loginWithGoogle,
    logout,
    loadWrongs,
    saveWrongs
  } from "./firebase-auth.js";

  // ---- DOM ----
  const lectureFilter = document.getElementById("lectureFilter");
  const countSelect = document.getElementById("countSelect");
  const modeSelect = document.getElementById("modeSelect");
  const modeHint = document.getElementById("modeHint");

  const btnStart = document.getElementById("btnStart");
  const btnWrong = document.getElementById("btnWrong");
  const btnWrongList = document.getElementById("btnWrongList");
  const btnWrongReset = document.getElementById("btnWrongReset");

  const questionEl = document.getElementById("question");
  const choicesEl = document.getElementById("choices");
  const resultBox = document.getElementById("resultBox");
  const resultText = document.getElementById("resultText");
  const explanationEl = document.getElementById("explanation");
  const btnNext = document.getElementById("btnNext");
  const btnToggleWrong = document.getElementById("btnToggleWrong");
  const btnUnderstood = document.getElementById("btnUnderstood");
  const statusEl = document.getElementById("status");
  const topStats = document.getElementById("topStats");

  const modalBg = document.getElementById("modalBg");
  const btnCloseModal = document.getElementById("btnCloseModal");
  const wrongListEl = document.getElementById("wrongList");
  const wrongCountPill = document.getElementById("wrongCountPill");
  const btnExportWrong = document.getElementById("btnExportWrong");

  const btnLogin = document.getElementById("btnLogin");
  const btnLogout = document.getElementById("btnLogout");
  const userLabel = document.getElementById("userLabel");

  // ---- storage ----
  const KEY_WRONG = "bio2_wrongs";
  const KEY_COUNT = "bio2_count_select";
  const KEY_MODE  = "bio2_mode_select";

  let wrongs = JSON.parse(localStorage.getItem(KEY_WRONG) || "[]");

  const savedCount = localStorage.getItem(KEY_COUNT);
  if (savedCount) countSelect.value = savedCount;

  const savedMode = localStorage.getItem(KEY_MODE);
  if (savedMode) modeSelect.value = savedMode;

  // ---- auth state ----
  let currentUser = null;
  let syncing = false;

  // ---- quiz state ----
  let pool = [];
  let index = 0;

  // ---- current rendered (mode may transform) ----
  let currentView = null;
  // currentView = { baseQ, questionText, choices[], answerIndex, explanationText }

  function shuffle(arr) {
    const a = [...arr];
    for (let i = a.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }

  function getFilteredQuestions() {
    const lec = lectureFilter.value;
    if (lec === "all") return QUESTIONS;
    return QUESTIONS.filter(q => String(q.lecture) === String(lec));
  }

  function getSelectedCount(maxAvailable) {
    const v = countSelect.value;
    if (v === "all") return maxAvailable;
    const n = parseInt(v, 10);
    if (!Number.isFinite(n) || n <= 0) return maxAvailable;
    return Math.min(n, maxAvailable);
  }

  function normalizeText(s) {
    return String(s || "").replace(/\s+/g, " ").trim();
  }

  function pickRandomDistinct(arr, k, excludeSet) {
    const candidates = arr.filter(x => !excludeSet.has(x));
    const shuffled = shuffle(candidates);
    return shuffled.slice(0, Math.min(k, shuffled.length));
  }

  // ---- Mode hints ----
  function updateModeHint() {
    const mode = modeSelect.value;
    let text = "";
    if (mode === "study_lock") {
      text = "ğŸ“˜ å‹‰å¼·ï¼šè§£èª¬ã‚’èª­ã‚“ã§ã€Œç†è§£ã—ãŸã€ã‚’æŠ¼ã™ã¾ã§æ¬¡ã¸é€²ã‚ã¾ã›ã‚“ï¼ˆå®šç€ç”¨ï¼‰";
    } else if (mode === "two_choice") {
      text = "âš¡ äºŒæŠï¼šã€æ­£ã—ã„/èª¤ã‚Šã€ã®2æŠã§ãƒ†ãƒ³ãƒè‰¯ãå›ã›ã¾ã™ï¼ˆåˆ¤æ–­åŠ›ï¼‰";
    } else if (mode === "term_desc") {
      text = "ğŸ§  å˜èªâ†’èª¬æ˜ï¼šé¸æŠè‚¢ã‚’ã€èª¬æ˜æ–‡ã€ã«å¤‰æ›ã—ã¦å‡ºé¡Œï¼ˆèª¬æ˜ã‚’è¦šãˆã‚‹ç”¨ï¼‰â€»èª¬æ˜ãŒçŸ­ã„å•é¡Œã¯è‡ªå‹•ã§é€šå¸¸ã«æˆ»ã—ã¾ã™";
    } else {
      text = "";
    }
    modeHint.style.display = text ? "" : "none";
    modeHint.textContent = text;
  }

  // ---- Build a view depending on mode ----
  function buildView(baseQ, mode) {
    const exp = normalizeText(baseQ.explanation);

    // safety: base question
    const baseView = {
      baseQ,
      questionText: `ï¼ˆç¬¬${baseQ.lecture}è¬›ï¼‰ ${baseQ.question}`,
      choices: baseQ.choices,
      answerIndex: baseQ.answer,
      explanationText: `æ­£è§£ï¼š${baseQ.answer + 1}. ${baseQ.choices[baseQ.answer]}\n\nè§£èª¬ï¼š${baseQ.explanation || ""}`,
      modeUsed: "normal"
    };

    if (mode === "two_choice") {
      // Use original wording; choices become correct/incorrect (2æŠ)
      // Determine correct by original answer: if choices contain "æ­£ã—ã„/èª¤ã‚Š" style, still fine.
      // We simply ask "ã“ã®è¨˜è¿°ã¯ï¼Ÿ" and map original correct choice to correct label:
      // If original choices are 4, we can't know which corresponds to "æ­£ã—ã„/èª¤ã‚Š".
      // So we transform ONLY when the original choices are exactly 2 and include æ­£ã—ã„/èª¤ã‚Š or similar.
      // Otherwise, we create 2æŠ by asking "ã“ã®è¨˜è¿°ã¯æœ€ã‚‚æ­£ã—ã„ï¼Ÿ" etc is not possible.
      // -> Safer: if original has exactly 2 choices, we keep; else we derive from question type using keywords.
      const qText = normalizeText(baseQ.question);
      const looksBinary =
        qText.includes("æ­£ã—ã„") || qText.includes("èª¤ã£ã¦") || qText.includes("èª¤ã‚Š") ||
        baseQ.choices.some(c => normalizeText(c).includes("æ­£ã—ã„")) ||
        baseQ.choices.some(c => normalizeText(c).includes("èª¤ã‚Š") || normalizeText(c).includes("èª¤ã£ã¦"));

      if (!looksBinary) return baseView;

      // Create 2 choices: æ­£ã—ã„ / èª¤ã‚Š
      // We need the truth value. If the question asks "æœ€ã‚‚æ­£ã—ã„/æœ€ã‚‚èª¤ã£ã¦ã„ã‚‹", it's not a statement truth test.
      // So we only do 2æŠ when it is clearly a statement judgement question (choices are already "æ­£ã—ã„/èª¤ã‚Š" OR question says choose correct/incorrect for a statement).
      const alreadyTwo = baseQ.choices.length === 2;
      const alreadyBinaryChoices =
        alreadyTwo &&
        (normalizeText(baseQ.choices[0]).includes("æ­£") || normalizeText(baseQ.choices[0]).includes("ã¯ã„") || normalizeText(baseQ.choices[0]).includes("Yes") ) &&
        (normalizeText(baseQ.choices[1]).includes("èª¤") || normalizeText(baseQ.choices[1]).includes("ã„ã„ãˆ") || normalizeText(baseQ.choices[1]).includes("No") );

      if (!alreadyTwo && (qText.includes("æœ€ã‚‚æ­£ã—ã„") || qText.includes("æœ€ã‚‚èª¤ã£ã¦ã„ã‚‹"))) {
        // This is a multi-choice selection type; don't force 2æŠ
        return baseView;
      }

      if (alreadyTwo) {
        return {
          ...baseView,
          choices: baseQ.choices,
          answerIndex: baseQ.answer,
          modeUsed: "two_choice"
        };
      }

      // fallback: map answerIndex 0 as "æ­£ã—ã„" 1 as "èª¤ã‚Š" not reliable -> don't do it
      return baseView;
    }

    if (mode === "term_desc") {
      // Need meaningful explanation to use as "definition"
      if (exp.length < 15) return baseView;

      // Term: use correct choice text as "term"
      const term = normalizeText(baseQ.choices[baseQ.answer]);
      if (!term || term.length < 2) return baseView;

      // Make 4 options = explanations from other questions' explanations
      const bank = getFilteredQuestions();

      // create distractor explanations
      const exclude = new Set([baseQ.id]);
      const distractorQs = pickRandomDistinct(bank, 20, exclude) // pick more then filter for long explanation
        .filter(q => normalizeText(q.explanation).length >= 15)
        .slice(0, 3);

      if (distractorQs.length < 3) return baseView;

      const correctDef = exp;
      const distractDefs = distractorQs.map(q => normalizeText(q.explanation));

      const choices = shuffle([correctDef, ...distractDefs]);

      const answerIndex = choices.indexOf(correctDef);

      return {
        baseQ,
        questionText: `ï¼ˆç¬¬${baseQ.lecture}è¬›ï¼‰ã€å˜èªâ†’èª¬æ˜ã€‘ã€Œ${term}ã€ã®èª¬æ˜ã¨ã—ã¦æœ€ã‚‚é©åˆ‡ãªã®ã¯ã©ã‚Œï¼Ÿ`,
        choices,
        answerIndex,
        explanationText:
          `æ­£è§£ï¼š${answerIndex + 1}\n\næ­£ã—ã„èª¬æ˜ï¼š${correctDef}\n\nï¼ˆå…ƒã®å•é¡Œï¼‰${baseQ.question}\nï¼ˆå…ƒã®æ­£è§£ï¼‰${baseQ.answer + 1}. ${term}`,
        modeUsed: "term_desc"
      };
    }

    // normal / study_lock: view is same as base, but navigation is locked later
    return baseView;
  }

  function renderTopStats() {
    const who = currentUser ? ` / ãƒ­ã‚°ã‚¤ãƒ³ä¸­` : ` / æœªãƒ­ã‚°ã‚¤ãƒ³ï¼ˆç«¯æœ«ä¿å­˜ï¼‰`;
    const mode = modeSelect.value;

    const filteredCount = getFilteredQuestions().length;
    const selected = getSelectedCount(filteredCount);
    const countText = selected === filteredCount ? `å…¨éƒ¨ï¼ˆ${filteredCount}ï¼‰` : `${selected}/${filteredCount}`;

    const modeLabel =
      mode === "study_lock" ? " / ğŸ“˜å‹‰å¼·(ãƒ­ãƒƒã‚¯)" :
      mode === "two_choice" ? " / âš¡äºŒæŠ" :
      mode === "term_desc" ? " / ğŸ§ å˜èªâ†’èª¬æ˜" : "";

    topStats.textContent = `å‡ºé¡Œæ•° ${countText} / ç·å•é¡Œ ${QUESTIONS.length} / é–“é•ã„ ${wrongs.length}${who}${modeLabel}`;
  }

  function start(kind) {
    let filtered = getFilteredQuestions();
    if (kind === "wrong") filtered = filtered.filter(q => wrongs.includes(q.id));

    const pickedN = getSelectedCount(filtered.length);
    pool = shuffle(filtered).slice(0, pickedN);

    index = 0;
    show();
  }

  function show() {
    resultBox.style.display = "none";
    btnNext.disabled = false;
    btnUnderstood.style.display = "none";

    if (!pool.length) {
      questionEl.textContent = "å•é¡ŒãŒã‚ã‚Šã¾ã›ã‚“ï¼ˆãƒ•ã‚£ãƒ«ã‚¿/é–“é•ã„ãŒ0ä»¶ï¼‰";
      choicesEl.innerHTML = "";
      statusEl.textContent = "";
      currentView = null;
      return;
    }
    if (index >= pool.length) {
      questionEl.textContent = "çµ‚äº†ï¼";
      choicesEl.innerHTML = "";
      statusEl.textContent = "";
      currentView = null;
      return;
    }

    const baseQ = pool[index];
    currentView = buildView(baseQ, modeSelect.value);

    questionEl.textContent = currentView.questionText;
    choicesEl.innerHTML = "";

    currentView.choices.forEach((c, i) => {
      const b = document.createElement("button");
      b.className = "choice";
      b.textContent = `${i + 1}. ${c}`;
      b.onclick = () => answer(i);
      choicesEl.appendChild(b);
    });

    statusEl.textContent = `é€²æ— ${index + 1} / ${pool.length}`;
  }

  function setToggleWrongButton(baseQ) {
    const isWrong = wrongs.includes(baseQ.id);
    btnToggleWrong.textContent = isWrong ? "ã“ã®å•é¡Œã‚’ã€Œé–“é•ã„ã€ã‹ã‚‰è§£é™¤" : "ã“ã®å•é¡Œã‚’ã€Œé–“é•ã„ã€ã«ã™ã‚‹";
    btnToggleWrong.className = isWrong ? "danger" : "secondary";
    btnToggleWrong.onclick = () => {
      toggleWrong(baseQ.id);
      setToggleWrongButton(baseQ);
    };
  }

  function toggleWrong(id) {
    if (wrongs.includes(id)) wrongs = wrongs.filter(x => x !== id);
    else wrongs.push(id);
    saveWrongsUniversal();
  }

  function answer(i) {
    if (!currentView) return;

    const baseQ = currentView.baseQ;
    const correct = i === currentView.answerIndex;

    resultBox.style.display = "block";
    resultBox.className = "result " + (correct ? "good" : "bad");

    const mode = modeSelect.value;

    // è¡¨ç¤ºãƒ†ã‚­ã‚¹ãƒˆ
    if (mode === "study_lock") {
      resultText.textContent = correct ? "âœ… æ­£è§£ï¼ˆè§£èª¬ã§å®šç€ï¼‰" : "âŒ ã“ã“ãŒå¼±ç‚¹ï¼ˆè§£èª¬ã§ä¿®æ­£ï¼‰";
    } else if (mode === "two_choice") {
      resultText.textContent = correct ? "âœ… æ­£è§£ï¼" : "âŒ ä¸æ­£è§£";
    } else if (mode === "term_desc") {
      resultText.textContent = correct ? "âœ… æ­£è§£ï¼" : "âŒ ä¸æ­£è§£";
    } else {
      resultText.textContent = correct ? "âœ… æ­£è§£ï¼" : "âŒ ä¸æ­£è§£";
    }

    explanationEl.textContent = currentView.explanationText;

    // ä¸æ­£è§£ã¯è‡ªå‹•ã§ã€Œé–“é•ã„ã€
    if (!correct && !wrongs.includes(baseQ.id)) {
      wrongs.push(baseQ.id);
      saveWrongsUniversal();
    }

    setToggleWrongButton(baseQ);

    // â˜…ã€Œç†è§£ã—ãŸã€ãƒ­ãƒƒã‚¯ãƒ¢ãƒ¼ãƒ‰
    if (mode === "study_lock") {
      btnNext.disabled = true;
      btnUnderstood.style.display = "";
      btnUnderstood.onclick = () => {
        btnNext.disabled = false;
        btnUnderstood.style.display = "none";
      };
    }
  }

  btnNext.onclick = () => { index++; show(); };

  btnStart.onclick = () => start("random");
  btnWrong.onclick = () => start("wrong");

  btnWrongReset.onclick = () => {
    wrongs = [];
    saveWrongsUniversal();
    alert("é–“é•ã„ãƒªã‚¹ãƒˆã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸã€‚");
  };

  // ---- é–“é•ã„ä¸€è¦§ ----
  function openWrongList() { modalBg.style.display = "flex"; renderWrongList(); }
  function closeWrongList() { modalBg.style.display = "none"; }

  function escapeHtml(s) {
    return String(s)
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;")
      .replaceAll('"', "&quot;")
      .replaceAll("'", "&#039;");
  }

  function renderWrongList() {
    const filteredBank = getFilteredQuestions();
    const wrongQuestions = filteredBank.filter(q => wrongs.includes(q.id));

    wrongCountPill.textContent = `${wrongQuestions.length} ä»¶`;
    wrongListEl.innerHTML = "";

    if (!wrongQuestions.length) {
      wrongListEl.innerHTML = `<div class="meta">é–“é•ã„ãŒã‚ã‚Šã¾ã›ã‚“ï¼ˆã¾ãŸã¯ãƒ•ã‚£ãƒ«ã‚¿ã§0ä»¶ï¼‰</div>`;
      return;
    }

    wrongQuestions
      .sort((a,b) => (a.lecture - b.lecture) || String(a.id).localeCompare(String(b.id)))
      .forEach(q => {
        const item = document.createElement("div");
        item.className = "listItem";

        const left = document.createElement("div");
        left.className = "left";
        left.innerHTML = `
          <div><span class="pill">ç¬¬${q.lecture}è¬›</span> <span class="pill">ID: ${escapeHtml(q.id)}</span></div>
          <div style="margin-top:6px;">${escapeHtml(q.question)}</div>
          <div class="small" style="margin-top:6px;">æ­£è§£ï¼š${q.answer + 1}. ${escapeHtml(q.choices[q.answer])}</div>
        `;

        const right = document.createElement("div");
        right.className = "row";

        const btnPreview = document.createElement("button");
        btnPreview.className = "secondary";
        btnPreview.textContent = "è¡¨ç¤º";
        btnPreview.onclick = () => {
          pool = [q];
          index = 0;
          show();

          // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æ™‚ã¯ã€Œçµæœè¡¨ç¤ºã ã‘å…ˆã«å‡ºã™ã€ã‚‚å¯èƒ½ã ã‘ã©ã€
          // æ—¢å­˜ã®å‹•ãã‚’å£Šã•ãªã„ã‚ˆã†ã“ã“ã§ã¯èª¬æ˜ã‚’é–‹ã„ã¦ãŠã
          resultBox.style.display = "block";
          resultBox.className = "result";
          resultText.textContent = "ï¼ˆãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ï¼‰";
          explanationEl.textContent =
            `æ­£è§£ï¼š${q.answer + 1}. ${q.choices[q.answer]}\n\nè§£èª¬ï¼š${q.explanation || ""}`;

          setToggleWrongButton(q);

          // lock modeå¯¾å¿œ
          if (modeSelect.value === "study_lock") {
            btnNext.disabled = true;
            btnUnderstood.style.display = "";
            btnUnderstood.onclick = () => {
              btnNext.disabled = false;
              btnUnderstood.style.display = "none";
            };
          } else {
            btnNext.disabled = false;
            btnUnderstood.style.display = "none";
          }

          closeWrongList();
        };

        const btnRemove = document.createElement("button");
        btnRemove.className = "danger";
        btnRemove.textContent = "è§£é™¤";
        btnRemove.onclick = () => {
          wrongs = wrongs.filter(x => x !== q.id);
          saveWrongsUniversal();
          renderWrongList();
        };

        right.appendChild(btnPreview);
        right.appendChild(btnRemove);

        item.appendChild(left);
        item.appendChild(right);
        wrongListEl.appendChild(item);
      });
  }

  btnWrongList.onclick = openWrongList;
  btnCloseModal.onclick = closeWrongList;
  modalBg.addEventListener("click", (e) => { if (e.target === modalBg) closeWrongList(); });

  btnExportWrong.onclick = async () => {
    const filteredBank = getFilteredQuestions();
    const wrongQuestions = filteredBank.filter(q => wrongs.includes(q.id));
    const text = wrongQuestions.map(q => q.id).join("\n");
    try { await navigator.clipboard.writeText(text); alert("é–“é•ã„IDã‚’ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸï¼"); }
    catch { alert("ã‚³ãƒ”ãƒ¼å¤±æ•—â€¦\nä¸€è¦§ã‹ã‚‰æ‰‹å‹•ã§ã‚³ãƒ”ãƒšã—ã¦ã­"); }
  };

  // ---- ä¿å­˜ï¼ˆãƒ­ã‚°ã‚¤ãƒ³ä¸­ã¯ã‚¯ãƒ©ã‚¦ãƒ‰ã‚‚ï¼‰ ----
  async function saveWrongsUniversal() {
    localStorage.setItem(KEY_WRONG, JSON.stringify(wrongs));

    if (currentUser && !syncing) {
      try { await saveWrongs(currentUser.uid, wrongs); }
      catch (e) { console.warn("ã‚¯ãƒ©ã‚¦ãƒ‰ä¿å­˜å¤±æ•—ï¼ˆç«¯æœ«ã«ã¯ä¿å­˜æ¸ˆã¿ï¼‰", e); }
    }
    renderTopStats();
  }

  // ---- ã‚»ãƒ¬ã‚¯ãƒˆä¿å­˜ ----
  countSelect.onchange = () => { localStorage.setItem(KEY_COUNT, countSelect.value); renderTopStats(); };
  modeSelect.onchange  = () => {
    localStorage.setItem(KEY_MODE, modeSelect.value);
    updateModeHint();
    renderTopStats();
    // é€”ä¸­ã§ãƒ¢ãƒ¼ãƒ‰å¤‰ãˆãŸæ™‚ã®äº‹æ•…é˜²æ­¢ï¼šä»Šã®å•é¡Œã¯ä¸€æ—¦ãƒªã‚»ãƒƒãƒˆè¡¨ç¤º
    resultBox.style.display = "none";
    btnNext.disabled = false;
    btnUnderstood.style.display = "none";
  };
  lectureFilter.onchange = () => { renderTopStats(); if (modalBg.style.display === "flex") renderWrongList(); };

  // ---- ãƒ­ã‚°ã‚¤ãƒ³ ----
  btnLogin.onclick = async () => {
    try { await loginWithGoogle(); }
    catch (e) { alert("ãƒ­ã‚°ã‚¤ãƒ³å¤±æ•—: " + (e?.message || e)); }
  };
  btnLogout.onclick = async () => {
    try { await logout(); }
    catch (e) { alert("ãƒ­ã‚°ã‚¢ã‚¦ãƒˆå¤±æ•—: " + (e?.message || e)); }
  };

  watchAuthState(async (user) => {
    currentUser = user;

    if (!user) {
      btnLogin.style.display = "";
      btnLogout.style.display = "none";
      userLabel.style.display = "none";
      renderTopStats();
      return;
    }

    btnLogin.style.display = "none";
    btnLogout.style.display = "";
    userLabel.style.display = "";
    userLabel.textContent = user.displayName || user.email || "ãƒ­ã‚°ã‚¤ãƒ³ä¸­";

    try {
      syncing = true;
      const cloudWrongs = await loadWrongs(user.uid);
      wrongs = Array.isArray(cloudWrongs) ? cloudWrongs : [];
      localStorage.setItem(KEY_WRONG, JSON.stringify(wrongs));
      renderTopStats();
      if (modalBg.style.display === "flex") renderWrongList();
    } finally {
      syncing = false;
    }
  });

  // init
  updateModeHint();
  renderTopStats();
  console.log("QUESTIONS loaded:", QUESTIONS?.length);
</script>
</body>
</html>
